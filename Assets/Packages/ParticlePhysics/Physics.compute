#define WARP_SIZE 64
#define MAX_THREAD_GROUPS 1024
#define MAX_X_THREADS (WARP_SIZE * MAX_THREAD_GROUPS)
#define G_CONST -9.81
#define COLLIDER_CAPACITY 10
#define BAND_LIMIT (20 * COLLIDER_CAPACITY)
#pragma kernel UploadVelocity
#pragma kernel UploadPosition
#pragma kernel UploadLife
#pragma kernel SimulateVelocity
#pragma kernel SimulatePosition
#pragma kernel SimulateLife
#pragma kernel SolveWallCollision
#pragma kernel SolveParticleCollision
#pragma kernel ClampVelocity
#pragma kernel CheckBounds
#pragma kernel InitHashes
#pragma kernel InitGrid
#pragma kernel ConstructGrid
#pragma kernel SolveCollisionDetection



static const float2 G = float2(0, G_CONST);
static const float MAX_VALUE = 10000.0;
static const int DEAD_HASH = -1;
static const int DEAD_GRID = -1;

struct Wall {
	float2 n;
	float2 t;
	float dn;
	float dt;
	float w;
	float h;
};
struct Collision {
	uint count;
	uint colliders[COLLIDER_CAPACITY];
};

static const float particleMass = 1;
static const float impulsiveMassCoeff = particleMass / (particleMass + particleMass);
static const float distanceEpsilon = 0.001;
static const float penetrationBias = 0.01;
static const float penetrationSlop = 0.01;
static const float maxSpeed = 20.0;
float dt;
float elastics;
float friction = 0.2;
float dragCoeff = 0.01;
float particleRadius;
float broadphaseSqrDistance;
float4 bounds;
int uploadOffset;
int uploadLength;
int wallCount;
int gridCapacity;
int grid_nx, grid_ny;
float4 gridParams;
RWStructuredBuffer<float2> VelocitiesCurr;
RWStructuredBuffer<float2> VelocitiesNext;
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float> Lifes;
RWStructuredBuffer<int> Hashes;
RWStructuredBuffer<uint> GridStarts;
RWStructuredBuffer<uint> GridEnds;
RWStructuredBuffer<Collision> Collisions;
StructuredBuffer<float2> Uploader;
StructuredBuffer<float> UploaderFloat;
StructuredBuffer<Wall> Walls;
StructuredBuffer<uint> BroadphaseKeys;



[numthreads(WARP_SIZE,1,1)]
void UploadVelocity (uint3 id : SV_DispatchThreadID) {
	uint velocitiesCapasity, stride;
	VelocitiesCurr.GetDimensions(velocitiesCapasity, stride);
	
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	uint j = (i + uploadOffset) % velocitiesCapasity;
	if (i >= (uint)uploadLength)
		return;
	VelocitiesCurr[j] = Uploader[i];
}
[numthreads(WARP_SIZE,1,1)]
void UploadPosition (uint3 id : SV_DispatchThreadID) {	
	uint positionsCapasity, stride;
	Positions.GetDimensions(positionsCapasity, stride);
	
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	uint j = (i + uploadOffset) % positionsCapasity;
	if (i >= (uint)uploadLength)
		return;
	Positions[j] = Uploader[i];
}
[numthreads(WARP_SIZE,1,1)]
void UploadLife(uint3 id : SV_DispatchThreadID) {
	uint lifesCapacity, stride;
	Lifes.GetDimensions(lifesCapacity, stride);
	
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	uint j = (i + uploadOffset) % lifesCapacity;
	if (i >= (uint)uploadLength)
		return;
	Lifes[j] = UploaderFloat[i];
}
[numthreads(WARP_SIZE,1,1)]
void SimulateVelocity(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	float2 v = VelocitiesCurr[i];
	VelocitiesNext[i] = v + dt * G - dt * dragCoeff * length(v) * v;
}
[numthreads(WARP_SIZE,1,1)]
void SimulatePosition(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	Positions[i] += dt * VelocitiesCurr[i];
}
[numthreads(WARP_SIZE,1,1)]
void SimulateLife(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	Lifes[i] = max(0.0, Lifes[i] - dt);
}
[numthreads(WARP_SIZE,1,1)]
void SolveWallCollision(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	float2 x = Positions[i];
	float2 v = VelocitiesCurr[i];
	
	float2 p = 0;
	float cpenet = penetrationBias / dt;
	for (int j = 0; j < wallCount; j++) {
		Wall wall = Walls[j];
		float v0n = dot(wall.n, v);
		float dn = dot(wall.n, x) - wall.dn;
		float dt = dot(wall.t, x) - wall.dt;
		if (abs(dn) > (wall.h + particleRadius) || abs(dt) > (wall.w + particleRadius))
			continue;
		float penet = cpenet * max(0.0, (wall.h + particleRadius - penetrationSlop) - dn);
		float pn = max(0.0, -(1.0 + elastics) * v0n + penet);
		float v0t = dot(wall.t, v);
		float pt = clamp(-v0t, -friction * pn, friction * pn);
		p += pn * wall.n + pt * wall.t;
	}
	
	VelocitiesNext[i] = v + p;
}
[numthreads(WARP_SIZE,1,1)]
void SolveParticleCollision(uint3 id : SV_DispatchThreadID) {
	uint lifesCapacity, stride;
	Lifes.GetDimensions(lifesCapacity, stride);
	
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	float ti = Lifes[i];
	float2 xi = Positions[i];
	float2 vi = VelocitiesCurr[i];
	if (ti <= 0.0)
		return;
	
	Collision b = Collisions[i];
	float2 p = 0;
	float colDist = 2.0 * particleRadius;
	float colMinDist = -particleRadius + distanceEpsilon;
	float cpenet = penetrationBias / dt;
	for (uint k = 0; k < b.count; k++) {
		uint j = b.colliders[k];
		float tj = Lifes[j];
		float2 xj = Positions[j];
		float2 dp = xi - xj;
		float d = length(dp) - colDist;
		if (i == j || tj <= 0.0 || 0 <= d || d <= colMinDist)
			continue;
		
		float2 vj = VelocitiesCurr[j];
		float2 v = vi - vj;
		float2 n = normalize(dp);
		float v0n = dot(n, v);
		float penet = cpenet * max(0.0, -(d + penetrationSlop));
		float pn = max(0.0, -impulsiveMassCoeff * (1.0 + elastics) * v0n + penet);
		float2 t = float2(n.y, -n.x);
		float v0t = dot(t, v);
		float pt = clamp(-v0t, -friction * pn, friction * pn);
		p += pn * n + pt * t;
	}
	VelocitiesNext[i] = vi + p;
}
[numthreads(WARP_SIZE,1,1)]
void ClampVelocity(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	float2 v = VelocitiesCurr[i];
	float a = length(v);
	VelocitiesNext[i] = clamp(a, -maxSpeed, maxSpeed) * normalize(v);
}
[numthreads(WARP_SIZE,1,1)]
void CheckBounds(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	float t = Lifes[i];
	float2 x = Positions[i];
	
	if (any(x < bounds.xy) || any(bounds.zw < x)) {
		Lifes[i] = 0.0;
	}
}
int Hash(float2 pos) {
	int2 ij = (int2)((pos - gridParams.xy * floor(pos / gridParams.xy)) * gridParams.zw);
	ij = clamp(ij, 0, int2(grid_nx, grid_ny)-1);
	return dot(ij, int2(1, grid_nx));
}
int2 RepeatGridIndex(int2 ij) {
	int2 n = int2(grid_nx, grid_ny);
	return ij - n * (int2)floor((float2)ij / n);
}
[numthreads(WARP_SIZE,1,1)]
void InitHashes(uint3 id : SV_DispatchThreadID) {
	uint capacity, stride;
	Positions.GetDimensions(capacity, stride);
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	if (i >= capacity)
		return;
	
	float t = Lifes[i];
	float2 x = Positions[i];
	Hashes[i] = (t > 0.0 ? Hash(x) : DEAD_HASH);
}
[numthreads(WARP_SIZE,1,1)]
void InitGrid(uint3 id : SV_DispatchThreadID) {
	uint capacity, stride;
	GridStart.GetDimensions(capacity, stride);
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	if (i >= capacity)
		return;
	
	GridStart[i] = DEAD_GRID;
	GridEnd[i] = DEAD_GRID;
}
[numthreads(WARP_SIZE,1,1)]
void ConstructGrid(uint3 id : SV_DispatchThreadID) {
	uint capacity, stride;
	Hashes.GetDimensions(capacity, stride);
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	if (i >= capacity)
		return;
	
	int hash = Hashes[BroadphaseKeys[i]];
	if (i == 0 || hash != Hashes[BroadphaseKeys[i-1]])
		GridStart[hash] = i;
	if (i == (capacity-1) || hash != Hashes[BroadphaseKeys[i+1]])
		GridEnd[hash] = i;
}
[numthreads(WARP_SIZE,1,1)]
void SolveCollisionDetection(uint3 id : SV_DispatchThreadID) {
	uint ysCapa, stride;
	Ys.GetDimensions(ysCapa, stride);
	uint k = dot(id.xy, uint2(1, MAX_X_THREADS));
	uint centerKey = BroadphaseKeys[k];
	float2 center = Positions[centerKey];
	
	uint colliders[COLLIDER_CAPACITY];
	uint count = 0;
	for (uint di = -1; di <= 1; di++) {
		for (uint dj = -1; dj <= 1; dj++) {
		}
	}
	
	Collision b;
	b.count = count;
	b.colliders = colliders;
	Collisions[centerKey] = b;
}
