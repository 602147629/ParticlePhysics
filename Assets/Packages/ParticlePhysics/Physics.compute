#define WARP_SIZE 64
#define MAX_THREAD_GROUPS 1024
#define MAX_X_THREADS (WARP_SIZE * MAX_THREAD_GROUPS)
#define G_CONST -9.81
#pragma kernel UploadVelocity
#pragma kernel UploadPosition
#pragma kernel UploadLife
#pragma kernel SimulateVelocity
#pragma kernel SimulatePosition
#pragma kernel SimulateLife
#pragma kernel SolveWallCollision



static const float2 G = float2(0, G_CONST);

struct Wall {
	float2 n;
	float2 t;
	float dn;
	float dt;
	float w;
	float h;
};

static const float particleRadius = 0.1;
static const float particleMass = 1;
float dt;
float elastics;
int uploadOffset;
int uploadLength;
int wallCount;
RWStructuredBuffer<float2> VelocitiesCurr;
RWStructuredBuffer<float2> VelocitiesNext;
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float> Lifes;
StructuredBuffer<float2> Uploader;
StructuredBuffer<float> UploaderFloat;
StructuredBuffer<Wall> Walls;



[numthreads(WARP_SIZE,1,1)]
void UploadVelocity (uint3 id : SV_DispatchThreadID) {
	uint velocitiesCapasity, stride;
	VelocitiesCurr.GetDimensions(velocitiesCapasity, stride);
	
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	uint j = (i + uploadOffset) % velocitiesCapasity;
	if (i >= (uint)uploadLength)
		return;
	VelocitiesCurr[j] = Uploader[i];
}
[numthreads(WARP_SIZE,1,1)]
void UploadPosition (uint3 id : SV_DispatchThreadID) {	
	uint positionsCapasity, stride;
	Positions.GetDimensions(positionsCapasity, stride);
	
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	uint j = (i + uploadOffset) % positionsCapasity;
	if (i >= (uint)uploadLength)
		return;
	Positions[j] = Uploader[i];
}
[numthreads(WARP_SIZE,1,1)]
void UploadLife(uint3 id : SV_DispatchThreadID) {
	uint lifesCapacity, stride;
	Lifes.GetDimensions(lifesCapacity, stride);
	
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	uint j = (i + uploadOffset) % lifesCapacity;
	if (i >= (uint)uploadLength)
		return;
	Lifes[j] = UploaderFloat[i];
}
[numthreads(WARP_SIZE,1,1)]
void SimulateVelocity(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	VelocitiesNext[i] = VelocitiesCurr[i] + dt * G;
}
[numthreads(WARP_SIZE,1,1)]
void SimulatePosition(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	Positions[i] += dt * VelocitiesCurr[i];
}
[numthreads(WARP_SIZE,1,1)]
void SimulateLife(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	Lifes[i] = max(0.0, Lifes[i] - dt);
}
[numthreads(WARP_SIZE,1,1)]
void SolveWallCollision(uint3 id : SV_DispatchThreadID) {
	uint i = dot(id.xy, uint2(1, MAX_X_THREADS));
	float2 x = Positions[i];
	float2 v = VelocitiesCurr[i];
	
	float2 p = 0;
	for (int j = 0; j < wallCount; j++) {
		Wall wall = Walls[j];
		float v0n = dot(wall.n, v);
		float dn = dot(wall.n, x) - wall.dn;
		if (v0n >= 0 || abs(dn) > (wall.h + particleRadius))
			continue;
		p += (particleMass * (1.0 + elastics) * v0n) * wall.n;
	}
	
	VelocitiesNext[i] = v - p / particleMass;
}
